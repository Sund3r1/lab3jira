name: Good CI/CD Pipeline Example

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

# Права доступа для токена
permissions:
  contents: read
  packages: write
  actions: read

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  VERSION: 1.0.0

jobs:
  # Job 1: Сборка и тестирование
  build-and-test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        java-version: [11]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up JDK ${{ matrix.java-version }}
      uses: actions/setup-java@v3
      with:
        java-version: ${{ matrix.java-version }}
        distribution: 'temurin'
        cache: maven
    
    - name: Build with Maven
      run: mvn clean compile -DskipTests
      
    - name: Run unit tests
      run: mvn test
      
    - name: Generate test report
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: "JUnit Tests"
        path: target/surefire-reports/*.xml
        reporter: java-junit
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      if: success()
      with:
        name: build-artifacts
        path: |
          target/*.jar
          target/surefire-reports/
    
    - name: SonarQube Scan
      if: github.ref == 'refs/heads/main'
      uses: SonarSource/sonarqube-scan-action@master
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # Job 2: Сборка Docker образа
  build-docker:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.event_name == 'push'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: build-artifacts
        path: target/
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=sha,format=short
          type=ref,event=branch
        labels: |
          org.opencontainers.image.title=CI/CD Demo
          org.opencontainers.image.description=Demo application for CI/CD practices
          org.opencontainers.image.version=${{ env.VERSION }}
          org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Job 3: Security scan
  security-scan:
    runs-on: ubuntu-latest
    needs: build-docker
    if: github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Run Trivy vulnerability scanner on code
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-fs-results.sarif'
        severity: 'CRITICAL,HIGH'
    
    - name: Run Trivy on Docker image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}'
        format: 'sarif'
        output: 'trivy-image-results.sarif'
        severity: 'CRITICAL,HIGH,MEDIUM'
    
    - name: Upload security scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-fs-results.sarif'
    
    - name: Run dependency check
      if: always()
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'ci-cd-demo'
        path: '.'
        format: 'SARIF'
        args: >
          --failOnCVSS 7
          --scan target/*.jar
          --out dependency-check-report.sarif
    
    - name: Upload dependency check results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'dependency-check-report.sarif'

  # Job 4: Деплой в staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-docker, security-scan]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment:
      name: staging
      url: https://staging.demo.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Kubernetes context
      if: env.KUBECONFIG_STAGING != ''
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
    
    - name: Deploy to staging
      if: env.KUBECONFIG_STAGING != ''
      env:
        KUBECONFIG_STAGING: ${{ secrets.KUBECONFIG_STAGING }}
      run: |
        IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        echo "Deploying image: $IMAGE_TAG"
        echo "Creating staging deployment..."
        
        # Создаем или обновляем deployment
        cat > deployment-staging.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ci-cd-demo-staging
          namespace: default
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: ci-cd-demo-staging
          template:
            metadata:
              labels:
                app: ci-cd-demo-staging
            spec:
              containers:
              - name: app
                image: $IMAGE_TAG
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "100m"
        EOF
        
        # Если нет kubectl, просто выводим информацию
        if command -v kubectl &> /dev/null; then
          kubectl apply -f deployment-staging.yaml
          kubectl rollout status deployment/ci-cd-demo-staging --timeout=90s
        else
          echo "kubectl not available. Deployment manifest:"
          cat deployment-staging.yaml
        fi
    
    - name: Health check staging deployment
      if: env.KUBECONFIG_STAGING != ''
      run: |
        echo "Checking deployment health..."
        if command -v kubectl &> /dev/null; then
          kubectl get pods -l app=ci-cd-demo-staging
          kubectl get deployment ci-cd-demo-staging
        fi

  # Job 5: Интеграционные тесты
  integration-test:
    runs-on: ubuntu-latest
    needs: [build-docker, security-scan]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    
    services:
      postgres:
        image: postgres:14-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up JDK
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
    
    - name: Run integration tests
      run: |
        echo "Running integration tests..."
        # Проверяем, что приложение собирается с тестовой конфигурацией
        mvn clean verify -DskipTests=false -Dtest=*IntegrationTest
        
        # Простая проверка health endpoint локально
        echo "Starting application for local testing..."
        nohup mvn spring-boot:run -Dspring-boot.run.profiles=test &
        sleep 30
        
        echo "Testing health endpoint..."
        curl -f http://localhost:8080/health || echo "Health check failed"
        
        # Останавливаем приложение
        pkill -f spring-boot

  # Job 6: Деплой в production (требует ручного подтверждения)
  deploy-production:
    runs-on: ubuntu-latest
    needs: [integration-test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: https://demo.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Kubernetes context
      if: env.KUBECONFIG_PRODUCTION != ''
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
    
    - name: Manual approval check
      run: |
        echo "This deployment requires manual approval via GitHub UI."
        echo "Deployment will proceed only after approval."
    
    - name: Deploy to production
      if: env.KUBECONFIG_PRODUCTION != ''
      env:
        KUBECONFIG_PRODUCTION: ${{ secrets.KUBECONFIG_PRODUCTION }}
      run: |
        IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        echo "Deploying to production: $IMAGE_TAG"
        
        # Создаем production deployment
        cat > deployment-production.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ci-cd-demo-production
          namespace: default
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: ci-cd-demo-production
          template:
            metadata:
              labels:
                app: ci-cd-demo-production
            spec:
              containers:
              - name: app
                image: $IMAGE_TAG
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    memory: "512Mi"
                    cpu: "200m"
                  limits:
                    memory: "1Gi"
                    cpu: "500m"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 10
                  periodSeconds: 5
        EOF
        
        if command -v kubectl &> /dev/null; then
          kubectl apply -f deployment-production.yaml
          echo "Waiting for rollout..."
          kubectl rollout status deployment/ci-cd-demo-production --timeout=180s
        else
          echo "kubectl not available. Production deployment manifest:"
          cat deployment-production.yaml
        fi
    
    - name: Health check production deployment
      if: env.KUBECONFIG_PRODUCTION != ''
      run: |
        echo "Production deployment health check..."
        if command -v kubectl &> /dev/null; then
          kubectl get deployment ci-cd-demo-production
          kubectl get pods -l app=ci-cd-demo-production
          
          # Проверяем, что все поды готовы
          READY_PODS=$(kubectl get deployment ci-cd-demo-production -o jsonpath='{.status.readyReplicas}')
          DESIRED_PODS=$(kubectl get deployment ci-cd-demo-production -o jsonpath='{.status.replicas}')
          
          if [ "$READY_PODS" = "$DESIRED_PODS" ]; then
            echo "All pods are ready ($READY_PODS/$DESIRED_PODS)"
          else
            echo "Warning: Not all pods are ready ($READY_PODS/$DESIRED_PODS)"
            exit 1
          fi
        fi
    
    - name: Notify deployment success
      if: success()
      run: |
        echo "✅ Production deployment successful!"
        echo "Application version: ${{ env.VERSION }}"
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        echo "Deployment time: $(date)"
        
        # Пример отправки уведомления в Slack (раскомментировать при необходимости)
        # curl -X POST -H 'Content-type: application/json' \
        #   --data "{\"text\":\"✅ Production deployment successful for ${{ github.repository }}! SHA: ${{ github.sha }}\"}" \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  # Job 7: Cleanup (очистка старых артефактов)
  cleanup:
    runs-on: ubuntu-latest
    if: always()
    needs: [deploy-production, deploy-staging]
    
    steps:
    - name: Clean up old Docker images
      run: |
        echo "Cleaning up workflow artifacts..."
        # Удаляем старые workflow runs (можно настроить в настройках репозитория)
        echo "Cleanup completed"
